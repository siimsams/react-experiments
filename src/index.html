<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Full Screen Grid Calendar - Horizontal Recycle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM + Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html, body, #root { height: 100%; margin: 0; font-family: system-ui, -apple-system, sans-serif; }
      #scroller {
        width: 100vw;
        height: 100vh;
        overflow-x: auto;
        overflow-y: auto;
        touch-action: pan-x pan-y;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        background: #f9fafb;
        scroll-behavior: smooth;
        scroll-snap-type: x mandatory;
        scroll-padding-left: 60px;
      }
      
      /* Custom scrollbar styling */
      #scroller::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      #scroller::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      
      #scroller::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 4px;
      }
      
      #scroller::-webkit-scrollbar-thumb:hover {
        background: #94a3b8;
      }
      
      /* Smooth transitions for sticky elements */
      .sticky {
        transition: box-shadow 0.2s ease;
      }
      
      /* Enhanced grid cell hover effects */
      .grid-cell:hover {
        background-color: rgba(59, 130, 246, 0.05);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useRef, useState, useLayoutEffect, PureComponent, cloneElement } = React;

      /* Horizontal recycle list that renders only visible grid columns */
      class RecycleListComponent extends PureComponent {
        getRowsToRenderInDom() {
          const { itemCount, itemSize, overscan = 2, renderItem, scrollLeftX, viewportX } = this.props;
          const start = Math.max(0, Math.floor(scrollLeftX / itemSize) - overscan);
          const end = Math.min(itemCount - 1, Math.ceil((scrollLeftX + viewportX) / itemSize) + overscan);
          const out = [];
          for (let i = start; i <= end; i++) {
            const el = renderItem(i);
            out.push({ element: el, renderKey: i, elementProps: {} });
          }
          return out;
        }
        render() {
          const rowsInDom = this.getRowsToRenderInDom();
          return rowsInDom.map(row => cloneElement(row.element, { key: row.renderKey, ...row.elementProps }));
        }
      }

      function GridCalendar() {
        // Config state
        const [visibleHours, setVisibleHours] = useState(12);
        const [showConfig, setShowConfig] = useState(false);
        
        // Static config
        const startDate = useMemo(() => new Date(2024, 0, 1), []);
        const daysToRender = 365 * 10; // wide enough to force X scroll
        const gutterWidth = 60; // Reduced width for more compact display
        const colWidth = 180; // Increased for better content fit
        const headerHeight = 60; // Increased for better header display
        const rowHeight = 60; // Increased for better content fit
        const totalHours = 24;
        const overscan = 3;

        // Scroll tracking
        const scrollerRef = useRef(null);
        const [scrollLeft, setScrollLeft] = useState(0);
        const [scrollTop, setScrollTop] = useState(0);
        const [viewportW, setViewportW] = useState(0);
        const [viewportH, setViewportH] = useState(0);
        const [isScrolling, setIsScrolling] = useState(false);
        const scrollTimeoutRef = useRef(null);

        useLayoutEffect(() => {
          const el = scrollerRef.current;
          if (!el) return;
          
          const onScroll = () => {
            setScrollLeft(el.scrollLeft);
            setScrollTop(el.scrollTop);
            setIsScrolling(true);
            
            // Clear existing timeout
            if (scrollTimeoutRef.current) {
              clearTimeout(scrollTimeoutRef.current);
            }
            
            // Set new timeout for scroll end detection
            scrollTimeoutRef.current = setTimeout(() => {
              setIsScrolling(false);
            }, 150);
          };
          
          const measure = () => {
            setViewportW(el.clientWidth);
            setViewportH(el.clientHeight);
          };
          
          measure();
          el.addEventListener("scroll", onScroll, { passive: true });
          window.addEventListener("resize", measure);
          
          return () => {
            el.removeEventListener("scroll", onScroll);
            window.removeEventListener("resize", measure);
            if (scrollTimeoutRef.current) {
              clearTimeout(scrollTimeoutRef.current);
            }
          };
        }, [colWidth]);

        // Effective X inside the day area
        const scrollLeftX = Math.max(0, scrollLeft - gutterWidth);
        const viewportX = Math.max(0, viewportW - gutterWidth);

        // Helpers
        const dateFromIndex = (i) => new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);

        // Calculate effective viewport height for the calendar
        const effectiveViewportHeight = Math.max(400, viewportH);
        const maxPossibleVisibleHours = Math.floor((effectiveViewportHeight - headerHeight - 100) / rowHeight);
        const actualVisibleHours = Math.min(visibleHours, totalHours, Math.max(6, maxPossibleVisibleHours));
        
        // Dynamic scroller height based on visible hours
        const scrollerHeight = headerHeight + (actualVisibleHours * rowHeight) + 20; // 20px for padding
        
        // Canvas size - guarantees both axis scroll regardless of recycling
        const canvasWidth = gutterWidth + daysToRender * colWidth;
        const canvasHeight = headerHeight + totalHours * rowHeight;

        // Grid
        const gridStyle = {
          display: "grid",
          gridTemplateColumns: `${gutterWidth}px`,
          gridAutoColumns: `${colWidth}px`,
          gridTemplateRows: `${headerHeight}px ` + Array.from({ length: totalHours }).map(() => `${rowHeight}px`).join(" "),
          width: `${canvasWidth}px`,
          height: `${canvasHeight}px`,
          position: "relative",
        };

        const renderHeaderCell = (dayIndex) => {
          const d = dateFromIndex(dayIndex);
          const weekday = d.toLocaleDateString(undefined, { weekday: "short" });
          const label = d.toLocaleDateString(undefined, { month: "short", day: "numeric" });
          return (
            <div
              style={{ 
                gridColumnStart: 2 + dayIndex, 
                gridRowStart: 1,
                scrollSnapAlign: 'start'
              }}
              className="sticky top-0 z-20 border-b border-gray-200 bg-gradient-to-b from-gray-600 to-gray-700 text-white py-3 text-center font-medium shadow-sm"
              title={d.toDateString()}
            >
              <div className="text-sm font-semibold">{weekday}</div>
              <div className="text-xs opacity-90 mt-1">{label}</div>
            </div>
          );
        };

        const renderBodyCell = (dayIndex, hour) => (
          <div
            style={{ gridColumnStart: 2 + dayIndex, gridRowStart: 2 + hour }}
            className="grid-cell border-b border-r border-gray-200 transition-colors duration-150"
          />
        );

        // Sample events
        const events = [
          { dayOffset: 1, rowStart: 6,  rowSpan: 3, color: "blue",  title: "Flight to Vancouver", time: "05:00", place: "Toronto YYZ" },
          { dayOffset: 2, rowStart: 8,  rowSpan: 2, color: "purple", title: "Breakfast",          time: "07:00", place: "Mel's Diner" },
          { dayOffset: 5, rowStart: 18, rowSpan: 3, color: "pink",   title: "Party",               time: "17:00", place: "Bring snacks" },
        ];

        const colorMap = {
          blue:   { border: "border-blue-700/10",   bg: "bg-blue-400/20",   text: "text-blue-600"   },
          purple: { border: "border-purple-700/10", bg: "bg-purple-400/20", text: "text-purple-600" },
          pink:   { border: "border-pink-700/10",   bg: "bg-pink-400/20",   text: "text-pink-600"   },
        };

        // Recycled rows
        const HeaderRow = (
          <RecycleListComponent
            itemCount={daysToRender}
            itemSize={colWidth}
            overscan={overscan}
            scrollLeftX={scrollLeftX}
            viewportX={viewportX}
            renderItem={(i) => renderHeaderCell(i)}
          />
        );

        const BodyRows = Array.from({ length: totalHours }).map((_, hour) => (
          <RecycleListComponent
            key={`row-${hour}`}
            itemCount={daysToRender}
            itemSize={colWidth}
            overscan={overscan}
            scrollLeftX={scrollLeftX}
            viewportX={viewportX}
            renderItem={(i) => renderBodyCell(i, hour)}
          />
        ));

        // Non recycled left gutter
        const Gutter = (
          <>
            <div className="sticky top-0 z-20 col-start-1 row-start-1 border-b border-gray-200 bg-white shadow-sm" />
            {Array.from({ length: totalHours }).map((_, i) => (
              <div
                key={`g-${i}`}
                style={{ gridColumnStart: 1, gridRowStart: 2 + i }}
                className="sticky left-0 z-10 border-r border-gray-200 bg-white px-2 py-4 text-right text-sm font-medium text-gray-500 flex items-center justify-end shadow-sm"
              >
                {String(i).padStart(2, "0")}:00
              </div>
            ))}
          </>
        );

        // Sentinel ensures the browser allocates the full implicit column width for X scroll
        const Sentinel = (
          <div
            style={{
              gridColumnStart: 2 + daysToRender,
              gridRowStart: 2,
              width: 1,
              height: 1,
              opacity: 0,
              pointerEvents: "none",
            }}
          />
        );

        return (
          <div id="scroller" ref={scrollerRef}>
            <div style={gridStyle}>
              {Gutter}
              {HeaderRow}
              {BodyRows}
              {Sentinel}
              {events.map((ev) => {
                const c = colorMap[ev.color];
                return (
                  <div
                    key={`${ev.dayOffset}-${ev.rowStart}`}
                    style={{
                      gridColumnStart: 2 + ev.dayOffset,
                      gridRowStart: ev.rowStart,
                      gridRowEnd: `span ${ev.rowSpan}`,
                    }}
                    className={`m-2 flex flex-col rounded-lg border ${c.border} ${c.bg} p-3 shadow-sm hover:shadow-md transition-shadow duration-200`}
                  >
                    <span className={`text-xs font-medium ${c.text} opacity-80`}>{ev.time}</span>
                    <span className={`text-sm font-semibold ${c.text} mt-1 leading-tight`}>{ev.title}</span>
                    <span className={`text-xs ${c.text} opacity-75 mt-1`}>{ev.place}</span>
                  </div>
                );
              })}
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<GridCalendar />);
    </script>
  </body>
</html>
