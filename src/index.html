<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Full Screen Grid Calendar - Horizontal Recycle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM + Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html, body, #root { height: 100%; margin: 0; }
      #scroller {
        width: 100vw;
        height: 100vh;
        overflow-x: auto;
        overflow-y: auto;
        touch-action: pan-x pan-y;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        background: #fff;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useRef, useState, useLayoutEffect, PureComponent, cloneElement } = React;

      /* Horizontal recycle list that renders only visible grid columns */
      class RecycleListComponent extends PureComponent {
        getRowsToRenderInDom() {
          const { itemCount, itemSize, overscan = 2, renderItem, scrollLeftX, viewportX } = this.props;
          const start = Math.max(0, Math.floor(scrollLeftX / itemSize) - overscan);
          const end = Math.min(itemCount - 1, Math.ceil((scrollLeftX + viewportX) / itemSize) + overscan);
          const out = [];
          for (let i = start; i <= end; i++) {
            const el = renderItem(i);
            out.push({ element: el, renderKey: i, elementProps: {} });
          }
          return out;
        }
        render() {
          const rowsInDom = this.getRowsToRenderInDom();
          return rowsInDom.map(row => cloneElement(row.element, { key: row.renderKey, ...row.elementProps }));
        }
      }

      function GridCalendar() {
        // Config
        const startDate = useMemo(() => new Date(2024, 0, 1), []);
        const daysToRender = 365 * 10; // wide enough to force X scroll
        const gutterWidth = 84;
        const colWidth = 150;
        const headerHeight = 40;
        const rowHeight = 50;
        const hours = 24;
        const overscan = 3;

        // Scroll tracking
        const scrollerRef = useRef(null);
        const [scrollLeft, setScrollLeft] = useState(0);
        const [viewportW, setViewportW] = useState(0);

        useLayoutEffect(() => {
          const el = scrollerRef.current;
          if (!el) return;
          const onScroll = () => setScrollLeft(el.scrollLeft);
          const measure = () => setViewportW(el.clientWidth);
          measure();
          el.addEventListener("scroll", onScroll, { passive: true });
          window.addEventListener("resize", measure);
          return () => {
            el.removeEventListener("scroll", onScroll);
            window.removeEventListener("resize", measure);
          };
        }, []);

        // Effective X inside the day area
        const scrollLeftX = Math.max(0, scrollLeft - gutterWidth);
        const viewportX = Math.max(0, viewportW - gutterWidth);

        // Helpers
        const dateFromIndex = (i) => new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);

        // Canvas size - guarantees both axis scroll regardless of recycling
        const canvasWidth = gutterWidth + daysToRender * colWidth;
        const canvasHeight = headerHeight + hours * rowHeight;

        // Grid
        const gridStyle = {
          display: "grid",
          gridTemplateColumns: `${gutterWidth}px`,
          gridAutoColumns: `${colWidth}px`,
          gridTemplateRows: `${headerHeight}px ` + Array.from({ length: hours }).map(() => `${rowHeight}px`).join(" "),
          width: `${canvasWidth}px`,
          height: `${canvasHeight}px`,
          position: "relative",
        };

        const renderHeaderCell = (dayIndex) => {
          const d = dateFromIndex(dayIndex);
          const weekday = d.toLocaleDateString(undefined, { weekday: "short" });
          const label = d.toLocaleDateString(undefined, { month: "short", day: "numeric" });
          return (
            <div
              style={{ gridColumnStart: 2 + dayIndex, gridRowStart: 1 }}
              className="sticky top-0 z-10 border-b border-gray-100 bg-gradient-to-b from-gray-600 to-gray-700 text-white py-2 text-center text-sm font-medium"
              title={d.toDateString()}
            >
              <div>{weekday}</div>
              <div className="text-xs opacity-80">{label}</div>
            </div>
          );
        };

        const renderBodyCell = (dayIndex, hour) => (
          <div
            style={{ gridColumnStart: 2 + dayIndex, gridRowStart: 2 + hour }}
            className="border-b border-r border-gray-200"
          />
        );

        // Sample events
        const events = [
          { dayOffset: 1, rowStart: 6,  rowSpan: 3, color: "blue",  title: "Flight to Vancouver", time: "05:00", place: "Toronto YYZ" },
          { dayOffset: 2, rowStart: 8,  rowSpan: 2, color: "purple", title: "Breakfast",          time: "07:00", place: "Mel's Diner" },
          { dayOffset: 5, rowStart: 18, rowSpan: 3, color: "pink",   title: "Party",               time: "17:00", place: "Bring snacks" },
        ];

        const colorMap = {
          blue:   { border: "border-blue-700/10",   bg: "bg-blue-400/20",   text: "text-blue-600"   },
          purple: { border: "border-purple-700/10", bg: "bg-purple-400/20", text: "text-purple-600" },
          pink:   { border: "border-pink-700/10",   bg: "bg-pink-400/20",   text: "text-pink-600"   },
        };

        // Recycled rows
        const HeaderRow = (
          <RecycleListComponent
            itemCount={daysToRender}
            itemSize={colWidth}
            overscan={overscan}
            scrollLeftX={scrollLeftX}
            viewportX={viewportX}
            renderItem={(i) => renderHeaderCell(i)}
          />
        );

        const BodyRows = Array.from({ length: hours }).map((_, hour) => (
          <RecycleListComponent
            key={`row-${hour}`}
            itemCount={daysToRender}
            itemSize={colWidth}
            overscan={overscan}
            scrollLeftX={scrollLeftX}
            viewportX={viewportX}
            renderItem={(i) => renderBodyCell(i, hour)}
          />
        ));

        // Non recycled left gutter
        const Gutter = (
          <>
            <div className="sticky top-0 z-10 col-start-1 row-start-1 border-b border-gray-200 bg-white" />
            {Array.from({ length: hours }).map((_, i) => (
              <div
                key={`g-${i}`}
                style={{ gridColumnStart: 1, gridRowStart: 2 + i }}
                className="sticky left-0 border-r border-gray-200 bg-white p-1.5 text-right text-xs font-medium text-gray-400"
              >
                {String(i).padStart(2, "0")}:00
              </div>
            ))}
          </>
        );

        // Sentinel ensures the browser allocates the full implicit column width for X scroll
        const Sentinel = (
          <div
            style={{
              gridColumnStart: 2 + daysToRender,
              gridRowStart: 2,
              width: 1,
              height: 1,
              opacity: 0,
              pointerEvents: "none",
            }}
          />
        );

        return (
          <div id="scroller" ref={scrollerRef}>
            <div style={gridStyle}>
              {Gutter}
              {HeaderRow}
              {BodyRows}
              {Sentinel}
              {events.map((ev) => {
                const c = colorMap[ev.color];
                return (
                  <div
                    key={`${ev.dayOffset}-${ev.rowStart}`}
                    style={{
                      gridColumnStart: 2 + ev.dayOffset,
                      gridRowStart: ev.rowStart,
                      gridRowEnd: `span ${ev.rowSpan}`,
                    }}
                    className={`m-1 flex flex-col rounded-lg border ${c.border} ${c.bg} p-1`}
                  >
                    <span className={`text-xs ${c.text}`}>{ev.time}</span>
                    <span className={`text-xs font-medium ${c.text}`}>{ev.title}</span>
                    <span className={`text-xs ${c.text}`}>{ev.place}</span>
                  </div>
                );
              })}
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<GridCalendar />);
    </script>
  </body>
</html>
